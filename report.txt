Задание делится на 3 части: 

1 часть: 
Сделать CRNG с энтропией rdrand. Настроил qemu для того, чтобы была доступна инструкция rdrand. Для запуска qemu со включенным rdrand надо
выполнить команду RDRAND=1 make qemu. В файле lib/rdrand.S реализована функция, вызывающая rdrand и записывающая его результат в переданную 
в качестве аргумента переменную, а возвращает она bool: доступен ли на платформе rdrand. В качестве CPRNG используется ISAAC. В нем есть 
массив состояния, который изначально инициализируется энтропией, а затем с помощью сдвигов массив итеративно генерируется заново. 
2 часть:
Сделать CRNG с программной энтропией. Один байт энтропии получается после замера промежутка времени между вызовами планировщика, 
из замера берется последний байт. В качестве CPRNG используется алгоритм Блюм-Блюма-Шуба.
Описание алгоритма Блюм-Блюма-Шуба(BBS).
Алгоритм принимает на вход два больших простых числа(p, q), сравнимых с 3 (по модулю 4) и начальное состояние генератора (х_0). 
Вычисляется произведение M = pq. 
Шаг генератора выглядит так:
	х_n+1 = (x_n) * (x_n) mod M. (текущее состояние генератора возводится в квадрат, затем от этого значения берется остаток по модулю M)
На каждом шаге алгоритма выходные данные получаются из x_n путём взятия бита чётности. Алгоритм имеет необычно высокую стойкость, 
которая обеспечивается качеством генератора исходя из вычислительной сложности задачи факторизации чисел.  

Описание тестов CPRNG: 
Все тесты были взяты из официального документа "A Statistical Test Suite for Random and Pseudorandom Number Generators 
for Cryptographic Applications by NIST".
Во всех тестах n означает длину последовательности битов, M - размер блока. Если параметр не используется, 
то он носит название "not_used" или "no_used" в заголовке функции. Такой подход был выбран для унифицированного интерфейса тестирования функций.

1) bool frequency_test(unsigned n, unsigned not_used, uint64_t (*func)());
Тест, который проверяет частоту вхождения 0 и 1 в последовательность. Для определения результата теста используется функция ошибок.

2) bool frequency_block_test(unsigned n, unsigned M, uint64_t (*func)());
Тест, аналогичный предыдущему. В этом тесте последовательность разбивается на блоки по M бит каждый. Считаются частоты для каждого блока, 
для определения результата теста используется распределение хи-квадрат и неполная гамма-функция.

3) bool runs_test(unsigned n, unsigned not_used, uint64_t (*func)());
Тест, в котором анализуется частота смены 0 и 1 в последовательности.

4) bool longest_run_of_ones_test(unsigned n, unsigned M, uint64_t (*func)());
Тест, в котором считается наибольшая длина битов "1" подряд и сравнивается с общей длиной последовательности.

5) bool binary_matrix_rank_test(unsigned no_used, unsigned not_used, uint64_t (*func)());
Тест, в котором последовательность бит разбивается на матрицы, после чего считается ранг каждой матрицы и анализуется количество матриц полного ранга, матриц с рангом на 1 меньше полного и остальных матриц. Для определения результата используется распределение хи-квадрат и неполная гамма-функция.

В текущей реализации тесты вызываются в monitor.c, для их запуска достаточно запустить RDRAND=1 make qemu, дождаться запуска в монитора, 
и в нем воспользоваться командой crng_test. Передав ей аргумент rdrand, протестируется первая часть задания, передав doom - вторая.

3 часть: 

Эллиптические кривые p_192 p_224 p_256 и тд берутся из стандарта nist (кривые не генерируются), 
они описаны вместе с базовыми точками и порядком группы в curve.c. 
Для подписи ecdsa передается сообщение и приватный ключ, публичный ключ генерируется в ecdsa_public_key. 
Для алгоритма требовалась хэш функция, для этого была взята md5 (md5.h md5.c) и библиотека для работы с большими числами 
и модульной арифметикой (bn.h bn.c).
Краткое описание алгоритма:
Генерация подписи:
1) Генерируется рандомное большое число k с помощью одной из функций, реализованных Артуром или Даниилом.
2) Базовая точка умножается на k с помощью функции из curve.c
3) x координата полученной точки заносится в r из (r, s)
4) s = k ^ (-1) * (z + r * da) mod n
5) если r или s ноль переходим к 1
6) (r, s) - подпись
Проверка подписи:
вычисляется P = u1 G + u2 HA
u1 = s ^ (-1) * z mod n
u2 = s ^ (-1) * r mod n
где HA - публичный ключ
z - хэш сообщения 

Тестирование: 
Берем сообщение, хешируем его, генерируем публичный и приватный ключи, а затем подписываем. Проверяем, что для приватного ключа и 
подписи verify выдает true. Затем проверяем, что если поменять хотя бы один бит в сообщении, а затем захешировать его, verify 
будет выдавать false. Кроме того проверяем, что если поменять публичный ключ, verify выдаст false.
